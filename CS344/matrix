#!/bin/bash

# given m1, m2

# dims()    Dimensions of the input matrix 
# # Input:  MxN matrix
# # Output: Prints the row and col count of the input matrix
dims(){
	n_cols=0
	n_rows=0
	
	#Count columns by counting tabs on first line
	 n_cols=$(awk '{print NF}' $1 | sort -nu | tail -n 1)
	
	#Count rows by counting lines
	n_rows=$(cat $1 | wc -l)
	
	#print the rows and columns, and new line
	printf "$n_rows $n_cols\n"
}

#	mean()	Mean row vector of the input matrix
# # Input:  MxN matrix
# # Output: 1xN row vector (each element is mean of associated column)
mean(){
	# Count row and cols using same methods from dims()
	n_rows=$(cat $1 | wc -l)
	n_cols=$(awk '{print NF}' $1 | sort -nu | tail -n 1)
	
	printf "Finding mean of columns\n"
	printf "$n_rows $n_cols\n"
	
	for ((i=0; i < $n_cols; i++)); do
		# Reset columns sum to 0 at beginning of each loop
		sum=0;
		
		# Iterate across columns (horizontally)
		for elem in $(cat $1 | cut -d $'\t' -f $((i + 1))); do 
			# Iterate down columns (vertically)
			sum=$((sum + elem))
		done
		
		# Adds a tab between elements
		if [ $i != "0" ]; then
			printf "\t"
		fi
		
		printf "%d" $(((sum + ($n_rows/2)*( (sum>0)*2-1 )) / $n_rows))
		# Equation provided. Prints mean of the row
	done
	#New line for formatting
	printf "\n"
}

#	transpose()	Flips input matrix diagonally
# # Input: 	MxN matrix
# # Output: NxM matrix with flipped values
transpose(){
	n_rows=$(cat $1 | wc -l)
	n_cols=$(awk '{print NF}' $1 | sort -nu | tail -n 1)
	
	for ((i=0; i < $n_cols; i++)); do
		# Iterate across columns (horizontally)
		for elem in $(cat $1 | cut -d $'\t' -f $((i + 1))); do 
			# Iterate down columns (vertically)
			# Prints the element
			printf "$elem"
			
			# Adds a tab between elements
			printf "\t"
		done
		# Print new lines between the transposed rows
		printf "\n"
	done
}

#	add()	Adds two matrices
# # Input:	Two matrices with the same dimesions (direction is irrelevant)
# #	Output: One matrix with the dimesions of the first matrix
add(){
	n1_rows=$(cat $1 | wc -l)
	n1_cols=$(awk '{print NF}' $1 | sort -nu | tail -n 1)

	n2_rows=$(cat $2 | wc -l)
	n2_cols=$(awk '{print NF}' $2 | sort -nu | tail -n 1)
	
	#declare two arrays, store files inside
	##mapfile -t m1 < $1
	##mapfile -t m2 < $2
	declare -a m1
	m1=$(cat $1)
	declare -a m2
	m2=$(cat $2)
	
	#if [n1_rows != n2_rows] || [n1_cols != n2_cols]
	#&& [n1_rows != n2_cols] || [n1_cols != n2_rows]; then
	if [[ ($n1_rows != $n2_rows || $n1_cols != $n2_cols) && ($n1_rows != $n2_cols || $n1_cols != $n2_rows) ]]; then
		# Dimensions are not identical, and not mirrored
		printf "Error: Matrices unmatched. Invalid operation.\n" >&2
		exit 1
	else 
		# Dimensions are the same: valid
		
		for ((i=0; i < $n1_rows; i++)); do
			# Iterate vertically
			for ((j=0; j < $n1_cols; j++)); do 
				# Iterate horizontally
				
				# n_elem converts 2D dimensions to 1D position in array
				n_elem=$(($i + ($j * $i)))
				cur_elem=0
				
				# Adds a tab between elements
				if [ $i != "0" ]; then
					printf "\t"
				fi
				
				if [ $n1_cols != $n2_cols ]; then
					# Correction for the narrower matrix
					# Row = 2* Rounded((curr row) + (curr col)/(n_cols))
					# Col = (curr col) % half of n_cols
					
					# Determine which matrix is wider
					if [ $n1_cols -lt $n2_cols ]; then
						printf "m1 narrower\n"
						
					elif [ $n1_cols -gt $n2_cols ]; then
						printf "m2 narrower\n"
						
					fi
				else
					# Correction not needed
					cur_elem=$((${m1[$n_elem]} + ${m2[$n_elem]}))
				fi
				
				# Prints the combined element
				printf "$cur_elem"
			done
			# Print new lines between the transposed rows
			printf "\n"
		done
		
	fi
}
#####################################################################
# Main script

# matrix [optn] [arg1] 	[arg2]
# matrix $1		$2		$3

# Use number of parameters the script is run with to decide to read from stdin or a file

# Error case for invalid option
if [ $# = "0" ]; then
    printf "Error: Must input a valid option.\n" >&2
    exit 1
elif [ $1 != "dims" ] && [ $1 != "transpose" ] && [ $1 != "mean" ] && [ $1 != "add" ] && [ $1 != "multiply" ]; then
    printf "Error: Invalid option.\n" >&2
    exit 1
fi

# Selecting option
# For 2 parameter options
if [ $1 = "dims" ] || [ $1 = "transpose" ] || [ $1 = "mean" ]; then 
	if [ $# -gt "2" ]; then
	# Too many inputs passed in
		printf "Error: Excess inputs.\n" >&2
		exit 1
	fi
	# Otherwise, number of options is valid
	
	# Determine if arguments will be passed in from file or from stdin. Check if file is readable
	data_file="data_file_$$"
	if [ "$#" = "1" ]; then
		cat > "$data_file" 
		# Read from stdin
	elif [ "$#" = "2" ]; then
		data_file=$2
		# Read from existing file
	fi
	
	if [[ ! -r $data_file ]]; then
        printf "Error: Input file unreadable.\n" >&2
        exit 1
    fi
	
	# If everything works, call the option
	$1 $data_file
	
	rm -rf data_file_*
	# Remove temp files
	
# For 3 parameter options
else 
	if [ $# != "3" ]; then
		# Too many/few inputs passed in
		printf "Error: Option requires two input matrices.\n" >&2
		exit 1
	elif [[ ! -r $2 || ! -w $2 || ! -r $3 || ! -w $3 ]]; then
		# File can't be read
        printf "Error: Input file(s) unreadable.\n" >&2
		exit 1
	fi
	# No errors, can run option. Use terminal inputs.
	$1 $2 $3
fi

# End of main script
#####################################################################
